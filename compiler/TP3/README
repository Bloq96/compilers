README file for Programming Assignment 3 (C++ edition)
======================================================

Your directory should now contain the following files:

 Makefile		  -> [course dir]/src/PA3/Makefile
 README
 cool.y
 bad.cl
 good.cl
 cool-tree.handcode.h
 cool-tree.cc		  -> [course dir]/src/PA3/cool-tree.cc
 cool-tree.aps		  -> [course dir]/src/PA3/cool-tree.aps
 dumptype.cc		  -> [course dir]/src/PA3/dumptype.cc
 handle_flags.c           -> [course dir]/src/PA3/handle_flags.cc
 parser-phase.cc	  -> [course dir]/src/PA3/parser-phase.cc
 stringtab.cc		  -> [course dir]/src/PA3/stringtab.cc
 tokens-lex.cc		  -> [course dir]/src/PA3/tokens-lex.cc
 tree.cc		  -> [course dir]/src/PA3/tree.cc
 utilities.cc		  -> [course dir]/src/PA3/utilities.cc
 *.d			  dependency files
 *.*			  other generated files

The include (.h) files for this assignment can be found in 
[course dir]/include/PA3

	The Makefile contains targets for compiling and running your
	program. DO NOT MODIFY.
    
	The README contains this info. Part of the assignment is to
	fill in the README with the write-up for your project. You should
	explain design decisions, explain why your code is correct, and why
	your test cases are adequate. It is part of the assignment to
	clearly and concisely explain things in text as well as to comment
	your code. Just edit this file.

	cool.y is the skeleton for the parser specification that you
	are to write. It already contains productions for the program
	and the classes. Use them as an example to write the remaining
	productions.  You should also read the bison documentation.
	This skeleton will compile and run as is, but it doesn't
	do much.

	good.cl, bad.cl test a few features of the grammar. You should
	add tests to ensure that good.cl exercises every legal
	construction of the grammar and that bad.cl exercises as many
	different parsing errors as you can squeeze into one file.

	cool-tree.aps contains the definitions for the tree language
	which you use to construct the abstract syntax tree (AST).
	From this file, cool-tree.h and cool-tree.cc are automatically 
        generated by a utility that compiles the specification into
        C++ functions for producing and consuming the tree nodes.
        This file is provided for your reference.  DO NOT MODIFY.

        tree.{cc|h} contain definitions used by the tree package.
        cool-tree.handcode.h is the handwritten extension to
        cool-tree.h.  If you read cool-tree.h and cool-tree.cc, you will
        note that there are "hooks" for extending the classes
        declarations.  Extending and modifying the tree package is
        discussed in the "Cool Tour", but you do not need to (and should
        not) modify the tree package for this assignment.

	tokens-lex.cc is a lexer capable of reading a token stream from
	console in the format produced by the lexer phase. DO NOT
	MODIFY.

        parser-phase.cc contains a driver to test the parser. DO NOT
        MODIFY.

	dumptype.cc prints the AST out in a form readable by the
	semant phase of the compiler. DO NOT MODIFY.

	handle_flags.cc implements routines for parsing command line
        flags. DO NOT MODIFY.

        The rest of the files are created as byproducts of `bison'.
        `cool-parse.cc' is the generated C++ file containing the
        parser.

	Files not discussed are covered in the README for PA2.

Instructions
------------

	To compile your parser program type:

	% gmake parser

	This produces an executable named "parser" which is standalone
	phase of the Cool compiler.  It requires lexer, semant, and cgen
	to do anything useful.

	To test your parser on a file 'foo.cl' type

	% myparser foo.cl

	myparser is a shell script that "glues" together lexer and
	parser using pipes.

	To run your parser on the files good.cl and bad.cl type:

	% gmake dotest

	If you think your parser is correct and behaves like
	the one we wrote, you may want to run a COOL compiler using
	your parser:

	% mycoolc foo.cl

	To overwrite the default lexical analyzer with yours, replace 
	lexer (which is a symbolic link to the "official" lexer) with
        your lexer from PA2.

	To turnin your work type:

	% gmake submit-clean

	And run the "submit" program following the instructions on the
	course web page.
	
	Running "submit" will collect the files cool.y, good.cl, bad.cl,
	good.output, bad.output, and README. Don't forget to edit the
	README file to include your write-up, and to write your own test
	cases in good.cl and bad.cl.

 	You may turn in the assignment as many times as you like.
	However, only the last version will be retained for
	grading.

	If you change architectures you must issue

	% gmake clean

	when you switch from one type of machine to the other.
	If at some point you get weird errors from the linker,	
	you probably forgot this step.

	GOOD LUCK!

---8<------8<------8<------8<---cut here---8<------8<------8<------8<---

Write-up for PA3
----------------
Dupla: Gabriel Ricardo Thomaz de Araújo - 2017002334
       Marcos Willian de Sales Reis - 2017002687
Erroos adcionais
Let com apenas o erro na variávelfinal e quando so tem um
parametros de função e corpo de função

casos errados no case;
casos errados na expressão case

- Códigos escritos

	Para a construção do parser múltiplas seções do arquivo cool.y
	foram alterados. Entre essas seções encontram-se:

	Declaração de novas funções/estruturas:
	- Let_structure: uma estrutura que contém o id da variável do
	let, o tipo dessa variável e a expressão de inicialização
	dela e a linha em que ela se encontra.
	- Expression letConruct(ListLet*, Let_structure, Expression):
	função para construir uma expressão com a lista de parâmetros
	de um expressão let a partir de uma expressão base, uma
	estrutura Let_structure base e uma lista de estrturas
	Let_structure.
	- void yyerror(char *): Função para impressão dos erros
	econtrados pelo parser.

	Union com todas as ações que podem ser resultado do
	parseamento: foram incluídos dois novos atributos a essa
	union, o Let_structure e um ponteiro para uma lista/vetor
	de elementos do tipo Let_structure.

	Sequência de tipos correspondentes aos não-terminais: Para
	cada um dos não terminais presentes na linguagem, foram
	associados um membro correspondente na Union. São eles:
	program, class_list, class, dummy_feature_list, feature,
	formal_list, formal, expr_list, dummy_expr_list, expr,
	case_match_list, case_match, let_declare, let_list.

	Definição de ordem de precedência: Da maior para a menor,
	foi definida a seguinte ordem de precedência: ., @, ~,
	isvoid, * e /, + e -, <= e < e =, not, <-, (, chamda de
	função, let. Sendo que todas esses elementos foram definidos
	como associativos a esquerta, exceto o (, que foi definido
	como não associativo e o <-, que foi definido como
	associativo à direita.

	Regras de derivação:
	- Um não terminal do tipo program pode derivar uma lista de
	classes (class_list). Como reultado, gera-se uma AST, cuja
	raiz ;
	- Uma class_list pode derivar outra class_list seguida de uma
	outra classe (class) ou uma única classe. Em ambos os casos,
	o resultado da derivação é uma lista de classes com uma ou
	mais classes. Caso uma classe ou uma lista de classe não
	sejam derivadas, resulta-se em erro.
	- Uma class pode derivar uma expressão de classe com ou sem
	herança. Neste caso, cria-se um nó de classe com o Id da
	classe, o Id da classe base (Object na ausência de herança
	explícita), uma lista de features (dummy_feature_list), e o
	nome do arquivo em que a classe está definida.
	- Uma dummy_feature_list deriva uma nova lista de features
	seguida de uma feature ou nada (lista vazia de features).
	Qualquer outra derivação causa erro. O resultado da
	derivação é uma lista com os nós de feature.
	- Uma feature resulta em uma expressão de feature, que pode
	ser um método sem argumentos, com um ou mais argumentos (
	formal formal_list) ou uma declaração de atributo seguida ou
	não de inicialização. No caso dos métodos, cria-se um nó de
	método com o Id dele, sua lista de parâmetros, seu tipo de
	retorno e seu corpo. No caso dos membros, cria-se um nó de
	atributo com o seu Id, tipo e prossivel expressão de valor.
	Erros podem surgir no que deveria ser a expressão do corpo
	do método ou no que deveria ser a lista de parâmetros dele.
	- Uma formal_list pode derivar uma formal_list seguido de
	um parâmetro (formal) separados por vírgula ou nada (lista
	de parâmetros vazia). Produz-se, então, uma lista com os nós
	de formal.
	- Um formal deriva uma expresão de parâmetro formal, da qual
	se criará um nó de parâmetro a partir do Id e do tipo
	presentes na expressão.
	- Um expr_list deriva uma expr ou uma list de expressões
	seguida de uma expressão (expr). Ambos os casos terminados
	em ';'. O resultado da derivação é uma lista de nós de
	expressão. Outras derivações resultam em erro.
	- Uma dummy_expr_list pode derivar nada (lista vazia) ou
	uma dummy_expr_list sequida de expr separadas por uma
	vírgula. O resultado dessa derivação também é uma lista
	de nós do tipo expressão.
	- Um let_declare gera uma expressão de declaração de variável
	que pode conter ou não uma inicialização. Dessa derivação,
	gera-se um Let_structure com os parâmetros correspondentes:
	id da variável, tipo, expressão de inicialização
	(possivelmente) e linha da declaração.
	- Um let_list pode derivar um let_list seguido de um
	let_declare ou um único let_declare. Isso produz uma lista
	de Let_structures (ListLet). O primeiro elemento da lista
	pode apresentar um erro, o que gera uma derivação de erro
	nesse caso.
	- Um case_match deriva uma expressão de case, da qual gera-se
	um nó de case a partir do Id, do tipo e da expressão
	correspondente do case. Qualquer derivação diferente gera
	erro.
	- Um case_match_list produz uma lista de nós case a partir da
	sua derivação em case_match ou case_match_list seguido de
	case_match.
	- Um expr apresenta múltiplas derivações que resultam em seus
	respectivos nós da AST. São elas: atribuição, chamada de
	método (com ou sem parâmtero e com ou sem indicação de classe
	ancestral), chamada de função, if, while/loop, let, case, new,
	isvoid, soma, subtração, multiplicação, divisão, desigualdade
	(menor que, menor ou igual a), igualdade, negação lógica, nome
	de objeto, contantes inteiras, booleanas e de texto. Podem
	surgir erros nas expressões do let (let_list) ou na expressão
	base do case.
	
- Decisões de projeto


- Testes realizados

	good.cl: 

	bad.cl: 
